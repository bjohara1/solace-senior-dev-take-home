{"ast":null,"code":"import{useState,useRef,useCallback}from'react';export const useAudioRecorder=()=>{const[isRecording,setIsRecording]=useState(false);const[audioBlob,setAudioBlob]=useState(null);const mediaRecorderRef=useRef(null);const audioChunksRef=useRef([]);const startRecording=useCallback(async()=>{try{const stream=await navigator.mediaDevices.getUserMedia({audio:{sampleRate:16000,channelCount:1,echoCancellation:true,noiseSuppression:true}});const mediaRecorder=new MediaRecorder(stream,{mimeType:'audio/webm;codecs=opus'});mediaRecorderRef.current=mediaRecorder;audioChunksRef.current=[];mediaRecorder.ondataavailable=event=>{if(event.data.size>0){audioChunksRef.current.push(event.data);}};mediaRecorder.onstop=()=>{const audioBlob=new Blob(audioChunksRef.current,{type:'audio/webm'});setAudioBlob(audioBlob);// Stop all tracks\nstream.getTracks().forEach(track=>track.stop());};mediaRecorder.start();setIsRecording(true);setAudioBlob(null);}catch(error){console.error('Error starting recording:',error);throw new Error('Failed to access microphone');}},[]);const stopRecording=useCallback(()=>{if(mediaRecorderRef.current&&isRecording){mediaRecorderRef.current.stop();setIsRecording(false);}},[isRecording]);return{startRecording,stopRecording,isRecording,audioBlob};};","map":{"version":3,"names":["useState","useRef","useCallback","useAudioRecorder","isRecording","setIsRecording","audioBlob","setAudioBlob","mediaRecorderRef","audioChunksRef","startRecording","stream","navigator","mediaDevices","getUserMedia","audio","sampleRate","channelCount","echoCancellation","noiseSuppression","mediaRecorder","MediaRecorder","mimeType","current","ondataavailable","event","data","size","push","onstop","Blob","type","getTracks","forEach","track","stop","start","error","console","Error","stopRecording"],"sources":["/Users/bradohara/solace/solace/task-C/src/hooks/useAudioRecorder.ts"],"sourcesContent":["import { useState, useRef, useCallback } from 'react';\n\nexport const useAudioRecorder = () => {\n  const [isRecording, setIsRecording] = useState(false);\n  const [audioBlob, setAudioBlob] = useState<Blob | null>(null);\n  \n  const mediaRecorderRef = useRef<MediaRecorder | null>(null);\n  const audioChunksRef = useRef<Blob[]>([]);\n\n  const startRecording = useCallback(async () => {\n    try {\n      const stream = await navigator.mediaDevices.getUserMedia({ \n        audio: {\n          sampleRate: 16000,\n          channelCount: 1,\n          echoCancellation: true,\n          noiseSuppression: true\n        } \n      });\n\n      const mediaRecorder = new MediaRecorder(stream, {\n        mimeType: 'audio/webm;codecs=opus'\n      });\n\n      mediaRecorderRef.current = mediaRecorder;\n      audioChunksRef.current = [];\n\n      mediaRecorder.ondataavailable = (event) => {\n        if (event.data.size > 0) {\n          audioChunksRef.current.push(event.data);\n        }\n      };\n\n      mediaRecorder.onstop = () => {\n        const audioBlob = new Blob(audioChunksRef.current, { type: 'audio/webm' });\n        setAudioBlob(audioBlob);\n        \n        // Stop all tracks\n        stream.getTracks().forEach(track => track.stop());\n      };\n\n      mediaRecorder.start();\n      setIsRecording(true);\n      setAudioBlob(null);\n\n    } catch (error) {\n      console.error('Error starting recording:', error);\n      throw new Error('Failed to access microphone');\n    }\n  }, []);\n\n  const stopRecording = useCallback(() => {\n    if (mediaRecorderRef.current && isRecording) {\n      mediaRecorderRef.current.stop();\n      setIsRecording(false);\n    }\n  }, [isRecording]);\n\n  return {\n    startRecording,\n    stopRecording,\n    isRecording,\n    audioBlob\n  };\n}; "],"mappings":"AAAA,OAASA,QAAQ,CAAEC,MAAM,CAAEC,WAAW,KAAQ,OAAO,CAErD,MAAO,MAAM,CAAAC,gBAAgB,CAAGA,CAAA,GAAM,CACpC,KAAM,CAACC,WAAW,CAAEC,cAAc,CAAC,CAAGL,QAAQ,CAAC,KAAK,CAAC,CACrD,KAAM,CAACM,SAAS,CAAEC,YAAY,CAAC,CAAGP,QAAQ,CAAc,IAAI,CAAC,CAE7D,KAAM,CAAAQ,gBAAgB,CAAGP,MAAM,CAAuB,IAAI,CAAC,CAC3D,KAAM,CAAAQ,cAAc,CAAGR,MAAM,CAAS,EAAE,CAAC,CAEzC,KAAM,CAAAS,cAAc,CAAGR,WAAW,CAAC,SAAY,CAC7C,GAAI,CACF,KAAM,CAAAS,MAAM,CAAG,KAAM,CAAAC,SAAS,CAACC,YAAY,CAACC,YAAY,CAAC,CACvDC,KAAK,CAAE,CACLC,UAAU,CAAE,KAAK,CACjBC,YAAY,CAAE,CAAC,CACfC,gBAAgB,CAAE,IAAI,CACtBC,gBAAgB,CAAE,IACpB,CACF,CAAC,CAAC,CAEF,KAAM,CAAAC,aAAa,CAAG,GAAI,CAAAC,aAAa,CAACV,MAAM,CAAE,CAC9CW,QAAQ,CAAE,wBACZ,CAAC,CAAC,CAEFd,gBAAgB,CAACe,OAAO,CAAGH,aAAa,CACxCX,cAAc,CAACc,OAAO,CAAG,EAAE,CAE3BH,aAAa,CAACI,eAAe,CAAIC,KAAK,EAAK,CACzC,GAAIA,KAAK,CAACC,IAAI,CAACC,IAAI,CAAG,CAAC,CAAE,CACvBlB,cAAc,CAACc,OAAO,CAACK,IAAI,CAACH,KAAK,CAACC,IAAI,CAAC,CACzC,CACF,CAAC,CAEDN,aAAa,CAACS,MAAM,CAAG,IAAM,CAC3B,KAAM,CAAAvB,SAAS,CAAG,GAAI,CAAAwB,IAAI,CAACrB,cAAc,CAACc,OAAO,CAAE,CAAEQ,IAAI,CAAE,YAAa,CAAC,CAAC,CAC1ExB,YAAY,CAACD,SAAS,CAAC,CAEvB;AACAK,MAAM,CAACqB,SAAS,CAAC,CAAC,CAACC,OAAO,CAACC,KAAK,EAAIA,KAAK,CAACC,IAAI,CAAC,CAAC,CAAC,CACnD,CAAC,CAEDf,aAAa,CAACgB,KAAK,CAAC,CAAC,CACrB/B,cAAc,CAAC,IAAI,CAAC,CACpBE,YAAY,CAAC,IAAI,CAAC,CAEpB,CAAE,MAAO8B,KAAK,CAAE,CACdC,OAAO,CAACD,KAAK,CAAC,2BAA2B,CAAEA,KAAK,CAAC,CACjD,KAAM,IAAI,CAAAE,KAAK,CAAC,6BAA6B,CAAC,CAChD,CACF,CAAC,CAAE,EAAE,CAAC,CAEN,KAAM,CAAAC,aAAa,CAAGtC,WAAW,CAAC,IAAM,CACtC,GAAIM,gBAAgB,CAACe,OAAO,EAAInB,WAAW,CAAE,CAC3CI,gBAAgB,CAACe,OAAO,CAACY,IAAI,CAAC,CAAC,CAC/B9B,cAAc,CAAC,KAAK,CAAC,CACvB,CACF,CAAC,CAAE,CAACD,WAAW,CAAC,CAAC,CAEjB,MAAO,CACLM,cAAc,CACd8B,aAAa,CACbpC,WAAW,CACXE,SACF,CAAC,CACH,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}