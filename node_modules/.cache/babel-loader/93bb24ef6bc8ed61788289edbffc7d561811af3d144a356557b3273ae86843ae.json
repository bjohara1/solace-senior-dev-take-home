{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useRef, useCallback } from 'react';\nexport const useAudioRecorder = () => {\n  _s();\n  const [isRecording, setIsRecording] = useState(false);\n  const [audioBlob, setAudioBlob] = useState(null);\n  const mediaRecorderRef = useRef(null);\n  const audioChunksRef = useRef([]);\n  const startRecording = useCallback(async () => {\n    try {\n      const stream = await navigator.mediaDevices.getUserMedia({\n        audio: {\n          sampleRate: 16000,\n          channelCount: 1,\n          echoCancellation: true,\n          noiseSuppression: true\n        }\n      });\n      const mediaRecorder = new MediaRecorder(stream, {\n        mimeType: 'audio/webm;codecs=opus'\n      });\n      mediaRecorderRef.current = mediaRecorder;\n      audioChunksRef.current = [];\n      mediaRecorder.ondataavailable = event => {\n        if (event.data.size > 0) {\n          audioChunksRef.current.push(event.data);\n        }\n      };\n      mediaRecorder.onstop = () => {\n        const audioBlob = new Blob(audioChunksRef.current, {\n          type: 'audio/webm'\n        });\n        setAudioBlob(audioBlob);\n\n        // Stop all tracks\n        stream.getTracks().forEach(track => track.stop());\n      };\n      mediaRecorder.start();\n      setIsRecording(true);\n      setAudioBlob(null);\n    } catch (error) {\n      console.error('Error starting recording:', error);\n      throw new Error('Failed to access microphone');\n    }\n  }, []);\n  const stopRecording = useCallback(() => {\n    if (mediaRecorderRef.current && isRecording) {\n      mediaRecorderRef.current.stop();\n      setIsRecording(false);\n    }\n  }, [isRecording]);\n  return {\n    startRecording,\n    stopRecording,\n    isRecording,\n    audioBlob\n  };\n};\n_s(useAudioRecorder, \"K8tECZAZwTYDc47oZ6k9LCutdFQ=\");","map":{"version":3,"names":["useState","useRef","useCallback","useAudioRecorder","_s","isRecording","setIsRecording","audioBlob","setAudioBlob","mediaRecorderRef","audioChunksRef","startRecording","stream","navigator","mediaDevices","getUserMedia","audio","sampleRate","channelCount","echoCancellation","noiseSuppression","mediaRecorder","MediaRecorder","mimeType","current","ondataavailable","event","data","size","push","onstop","Blob","type","getTracks","forEach","track","stop","start","error","console","Error","stopRecording"],"sources":["/Users/bradohara/solace/solace/task-C/src/hooks/useAudioRecorder.ts"],"sourcesContent":["import { useState, useRef, useCallback } from 'react';\n\nexport const useAudioRecorder = () => {\n  const [isRecording, setIsRecording] = useState(false);\n  const [audioBlob, setAudioBlob] = useState<Blob | null>(null);\n  \n  const mediaRecorderRef = useRef<MediaRecorder | null>(null);\n  const audioChunksRef = useRef<Blob[]>([]);\n\n  const startRecording = useCallback(async () => {\n    try {\n      const stream = await navigator.mediaDevices.getUserMedia({ \n        audio: {\n          sampleRate: 16000,\n          channelCount: 1,\n          echoCancellation: true,\n          noiseSuppression: true\n        } \n      });\n\n      const mediaRecorder = new MediaRecorder(stream, {\n        mimeType: 'audio/webm;codecs=opus'\n      });\n\n      mediaRecorderRef.current = mediaRecorder;\n      audioChunksRef.current = [];\n\n      mediaRecorder.ondataavailable = (event) => {\n        if (event.data.size > 0) {\n          audioChunksRef.current.push(event.data);\n        }\n      };\n\n      mediaRecorder.onstop = () => {\n        const audioBlob = new Blob(audioChunksRef.current, { type: 'audio/webm' });\n        setAudioBlob(audioBlob);\n        \n        // Stop all tracks\n        stream.getTracks().forEach(track => track.stop());\n      };\n\n      mediaRecorder.start();\n      setIsRecording(true);\n      setAudioBlob(null);\n\n    } catch (error) {\n      console.error('Error starting recording:', error);\n      throw new Error('Failed to access microphone');\n    }\n  }, []);\n\n  const stopRecording = useCallback(() => {\n    if (mediaRecorderRef.current && isRecording) {\n      mediaRecorderRef.current.stop();\n      setIsRecording(false);\n    }\n  }, [isRecording]);\n\n  return {\n    startRecording,\n    stopRecording,\n    isRecording,\n    audioBlob\n  };\n}; "],"mappings":";AAAA,SAASA,QAAQ,EAAEC,MAAM,EAAEC,WAAW,QAAQ,OAAO;AAErD,OAAO,MAAMC,gBAAgB,GAAGA,CAAA,KAAM;EAAAC,EAAA;EACpC,MAAM,CAACC,WAAW,EAAEC,cAAc,CAAC,GAAGN,QAAQ,CAAC,KAAK,CAAC;EACrD,MAAM,CAACO,SAAS,EAAEC,YAAY,CAAC,GAAGR,QAAQ,CAAc,IAAI,CAAC;EAE7D,MAAMS,gBAAgB,GAAGR,MAAM,CAAuB,IAAI,CAAC;EAC3D,MAAMS,cAAc,GAAGT,MAAM,CAAS,EAAE,CAAC;EAEzC,MAAMU,cAAc,GAAGT,WAAW,CAAC,YAAY;IAC7C,IAAI;MACF,MAAMU,MAAM,GAAG,MAAMC,SAAS,CAACC,YAAY,CAACC,YAAY,CAAC;QACvDC,KAAK,EAAE;UACLC,UAAU,EAAE,KAAK;UACjBC,YAAY,EAAE,CAAC;UACfC,gBAAgB,EAAE,IAAI;UACtBC,gBAAgB,EAAE;QACpB;MACF,CAAC,CAAC;MAEF,MAAMC,aAAa,GAAG,IAAIC,aAAa,CAACV,MAAM,EAAE;QAC9CW,QAAQ,EAAE;MACZ,CAAC,CAAC;MAEFd,gBAAgB,CAACe,OAAO,GAAGH,aAAa;MACxCX,cAAc,CAACc,OAAO,GAAG,EAAE;MAE3BH,aAAa,CAACI,eAAe,GAAIC,KAAK,IAAK;QACzC,IAAIA,KAAK,CAACC,IAAI,CAACC,IAAI,GAAG,CAAC,EAAE;UACvBlB,cAAc,CAACc,OAAO,CAACK,IAAI,CAACH,KAAK,CAACC,IAAI,CAAC;QACzC;MACF,CAAC;MAEDN,aAAa,CAACS,MAAM,GAAG,MAAM;QAC3B,MAAMvB,SAAS,GAAG,IAAIwB,IAAI,CAACrB,cAAc,CAACc,OAAO,EAAE;UAAEQ,IAAI,EAAE;QAAa,CAAC,CAAC;QAC1ExB,YAAY,CAACD,SAAS,CAAC;;QAEvB;QACAK,MAAM,CAACqB,SAAS,CAAC,CAAC,CAACC,OAAO,CAACC,KAAK,IAAIA,KAAK,CAACC,IAAI,CAAC,CAAC,CAAC;MACnD,CAAC;MAEDf,aAAa,CAACgB,KAAK,CAAC,CAAC;MACrB/B,cAAc,CAAC,IAAI,CAAC;MACpBE,YAAY,CAAC,IAAI,CAAC;IAEpB,CAAC,CAAC,OAAO8B,KAAK,EAAE;MACdC,OAAO,CAACD,KAAK,CAAC,2BAA2B,EAAEA,KAAK,CAAC;MACjD,MAAM,IAAIE,KAAK,CAAC,6BAA6B,CAAC;IAChD;EACF,CAAC,EAAE,EAAE,CAAC;EAEN,MAAMC,aAAa,GAAGvC,WAAW,CAAC,MAAM;IACtC,IAAIO,gBAAgB,CAACe,OAAO,IAAInB,WAAW,EAAE;MAC3CI,gBAAgB,CAACe,OAAO,CAACY,IAAI,CAAC,CAAC;MAC/B9B,cAAc,CAAC,KAAK,CAAC;IACvB;EACF,CAAC,EAAE,CAACD,WAAW,CAAC,CAAC;EAEjB,OAAO;IACLM,cAAc;IACd8B,aAAa;IACbpC,WAAW;IACXE;EACF,CAAC;AACH,CAAC;AAACH,EAAA,CA9DWD,gBAAgB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}